<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Advanced Topics</title><link rel="stylesheet" href="stylesheets/scribe.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.74.1" /><link rel="home" href="index.html" title="Couchbase Ruby Client Manual" /><link rel="up" href="index.html" title="Couchbase Ruby Client Manual" /><link rel="prev" href="ar01s02.html" title="Working with Documents" /><link rel="next" href="ar01s04.html" title="Couchbase Rails Tutorial" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Advanced Topics</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_advanced_topics"></a>Advanced Topics</h2></div></div></div><p>This chapter introduces some techniques topics that you can use to
further extend your Couchbase vocabulary.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_cas_and_locking"></a>CAS and Locking</h3></div></div></div><p>If you need to coordinate shared access on documents, Couchbase helps
you with two approaches. Depending on the application you may need to
use both of them, but in general it is better (if feasible) to lean
towards CAS because it provides the better performance
characteristics.</p><p><b>Optimistic Locking. </b>Each document has a unique identifier associated with it (the CAS
value), which changes when the document itself is mutated. You can
fetch the CAS value for a given key and pass it to any mutator
operation to protect it. The update will only succeed, when the CAS
value is still the same. This is why it’s called optimistic locking.
Someone else can still read and try to update the document, but it
will fail once the CAS value has changed. Here is a example on how to
do it with the Ruby SDK:</p><pre class="programlisting">key = "eagle_brewing-golden"
# Reads the document with the CAS value.
beer, flags, cas = client.get(key, :extended =&gt; true)

# Updates the document and tries to store it back.
beer["name"] = "Some other Name"
client.set(key, beer, :cas =&gt; cas, :flags =&gt; flags)</pre><p>Note that this also means that all your application need to follow the
same code path (cooperative locking). If you use <code class="literal">#set</code> somewhere else
in the code on the same document, it will work even if the CAS itself
is out of date (that’s because the normal <code class="literal">#set</code> method doesn’t care
about those values at all). Of course, the CAS itself changes then and
the mutation operation would fail afterwards.</p><p>There is also shortcut operation for doing optimistic locking
<code class="literal">Bucket#cas</code>. Internally it does the same thing but abstract you from
storing and passing meta information. Here is the previous example
rewritten to use this operation:</p><pre class="programlisting">key = "eagle_brewing-golden"
client.cas(key) do |beer|
  beer["name"] = "Some other Name"
  # return new value from block
  beer
end</pre><p>Note that you should return new value from the block. If you will skip
it, it will use <code class="literal">"Some other Name"</code> as new value.</p><p><b>Pessimistic Locking. </b>If you want to lock a document completely (or an object graph), you
can use the <code class="literal">Bucket#get</code> operation with <code class="literal">:lock</code> option. The option
accepts either boolean (where truth does make sense really) or Fixnum
meaning the time period where the lock is valid. The server will
release lock after the that period (or maximum value, which configured
on the server). Other threads can still run <code class="literal">get</code> queries queries
against the document, but mutation operations without a CAS will fail.</p><p>You can determine actual default and maximum values calling
<code class="literal">Bucket#stats</code> without arguments and inspecting keys
<code class="literal">"ep_getl_default_timeout"</code> and <code class="literal">"ep_getl_max_timeout"</code>
correspondingly.</p><pre class="programlisting">key = "eagle_brewing-golden";

# Get with Lock
beer, flags, cas = client.get(key, :lock =&gt; true, :extended =&gt; true);

# Update the document
beer["name"] = "Some other Name"

# Try to set without the lock
client.set(key, beer, :flags =&gt; flags)
#=&gt; will raise Couchbase::Error::KeyExists

# Try to set with the CAS aquired, will be OK
client.set(key, beer, :flags =&gt; flags, :cas =&gt; cas)</pre><p>Once you update the document, the lock will be released. There is also
the <code class="literal">Bucket#unlock</code> method available through which you can unlock the
document.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_persistence_and_replication"></a>Persistence and Replication</h3></div></div></div><p>By default, the mutation operations return when Couchbase Server has
accepted the command and stored it in memory (disk persistence and
replication is handled asynchronously by the cluster). That’s one of
the reason why it’s so fast. For most use-cases, that’s the behavior
that you need. Sometimes though, you want to trade in performance for
data-safety and wait until the document has been saved to disk and/or
replicated to other hosts.</p><p>The Ruby SDK provides <code class="literal">:observe</code> option for all mutation operations.
You can claim various persistence conditions using this option.
Basically its argument is a Hash with three possible keys, describing
the condition when the mutator will yield the result:</p><div class="orderedlist"><ol type="1"><li>
<code class="literal">:replicated</code> (Fixnum) describe how many nodes should receive
replicated copy of the document.
</li><li>
<code class="literal">:persisted</code> (Fixnum) describe how many nodes should persist the
document to the disk. The nodes include master node, where the key
resides and all replica nodes.
</li><li>
<code class="literal">:timeout</code> (Fixnum) the timeout period in microseconds. After
passing, the operation condition will be considered timed out and
appropriate exception will be thrown. Default value could be addressed
using <code class="literal">Bucket#default_observe_timeout</code>.
</li></ol></div><p>Here is an example on how to make sure that the document has been
persisted on its master node, but also replicated to at least one of
its replicas.</p><pre class="programlisting">key = "important"
value = "document"
client.set(key, value, :observe =&gt; {:persisted =&gt; 1, :replicated =&gt; 1})</pre><p>You can also separate persistence requirement from actual operations,
and in this case, you can wait for several keys:</p><pre class="programlisting">keys = []
(1..5).each do |nn|
  key = "important-#{nn}"
  keys &lt;&lt; key
  client.set(key, "document-#{nn}")
end
client.observe_and_wait(keys, :persisted =&gt; 1, :replicated =&gt; 1)</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Working with Documents </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Couchbase Rails Tutorial</td></tr></table></div></body></html>
