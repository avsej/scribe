== Couchbase Rails Tutorial

The goal of this chapter is to show how to write more advanced
application using Couchbase and Rails framework.

We assume here that you are passed "Getting Started" section already,
if not, we recommend to take a look, because it describes how to
install and verify Ruby SDK.

=== TL;DR

For the purposes of this tutorial, we have specially prepared an
example application for you to follow along with. The application is
using bucket with one of the sample datasets which come with Couchbase
Server itself: `beer-sample`. If you haven't already, download the
latest Couchbase Server 2.0 release and install it. While following
the download instructions and setup wizard, make sure install the
`beer-sample` default bucket. It contains sample data of beers and
breweries, which we'll be using in our examples here. If you've
already installed Couchbase Server 2.0 and didn't install the
`beer-sample` bucket (or if you deleted it), just open the Web-UI and
navigate to "Settings/Sample Buckets".  Activate the `beer-sample`
checkbox and click "Create". In the right hand corner you'll see a
notification box that will disappear once the bucket is ready to be
used.

After that you can just clone complete repository from github account:

----
shell> git clone git://github.com/couchbaselabs/couchbase-beer.rb.git
Cloning into 'couchbase-beer.rb'...
remote: Counting objects: 409, done.
remote: Compressing objects: 100% (254/254), done.
remote: Total 409 (delta 183), reused 340 (delta 114)
Receiving objects: 100% (409/409), 235.17 KiB | 130 KiB/s, done.
Resolving deltas: 100% (183/183), done.
----

Navigate to the directory and install all application dependencies:

----
shell> cd couchbase-beer.rb/
shell> bundle install
...snip...
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
----

That's it. Assuming that the server with `beer-sample` bucket is up
and running on localhost, you can just start ruby web server and
navigate to http://localhost:3000/. You should see something like that:

image::image/couchbase-beer.rb-home.png[]

=== Create Application Skeleton

If you are interesting how to create this application from scratch
just continue reading. As with any rails application we will use
generators a lot. As far as we don't need ActiveRecord lets inform
`rails new` about it.

----
shell> rails new couchbase-beer.rb -O --old-style-hash
----

Now navigate to the project root and open up `Gemfile` in your
favourite editor. First of all we need to add Couchbase libraries there:

[source,ruby]
----
gem 'couchbase'
gem 'couchbase-model'
----

Skipping version will get the latest stable versions of those gems. We
will use https://rubygems.org/gems/couchbase-model[couchbase-model]
gem to define our models in declarative way, like all rails developers
used to describe their models with ActiveRecord. Apart from that we
will use `yajl-ruby`, a high-performance JSON parser/generator,
`rdiscount` to render descriptions as Markdown, and `omniauth-twitter`
for authentication users.

[source,ruby]
----
gem 'yajl-ruby'
gem 'rdiscount'
gem 'omniauth-twitter'
----

The complete `Gemfile` will looks like this one:

.Gemfile
[ruby]
source~~~~
include::include/Gemfile[]
source~~~~

Next step will be to configure Couchbase connection, this step should
be also familiar to rails developer, because `couchbase-model` brings
YAML-styled configuration to you, so if you know how
`config/database.yml` works, you might guess what
`config/couchbase.yml` for. To generate config, use `couchbase:config`
generator:

----
shell> rails generate couchbase:config
      create  config/couchbase.yml
----

As far as our bucket name differs from project name, you should update
`bucket` property in the config. Also if your Couchbase Server is
running not on local machine, you should also fill proper hostname
there. After modifications your config should look like this:

.config/couchbase.yml
----
common: &common
  hostname: localhost
  port: 8091
  username:
  password:
  pool: default

development:
  <<: *common
  bucket: beer-sample

production:
  <<: *common
  bucket: beer-sample
----

That's all for configuration, lets move forward and create some
models.

=== Define Models

To create a model, all you need is just define class and inherit from
`Couchbase::Model`. Lets dissect `Brewery` model from the application.

.app/models/brewery.rb
[source,ruby]
----
class Brewery < Couchbase::Model
  attribute :name, :description
  attribute :country, :state, :city, :address
  attribute :phone
  attribute :geo
  attribute :updated

  view :all, :limit => 31
  view :all_with_beers
  view :by_country, :include_docs => false, :group => true
  view :points, :spatial => true

  def full_address
    [country, state, city, address].reject(&:blank?).join(', ')
  end

  def location
    [country, state].reject(&:blank?).join(', ')
  end
end
----

First part of the model contains attribute definitions, `attribute`
macro defines a pair of accessors and helps to maintain map of
attributes-values. You can also specify default value for each
attribute:

[source,ruby]
----
class Post < Couchbase::Model
  attribute :title, :body
  attribute :timestamp, :default => lambda{ Time.now }
end

Post.new(:title => "Hello, World!")
#=> #<Post timestamp: 2012-12-07 16:03:56 +0300, title: "Hello, World!">
----

Next block is about defining views. One way to play with views is
Couchbase Server Admin Console, but it isn't very easy to keep parts
of code in different places. After all Views are implemented in
Javascript and carry part of business logic. `couchbase-model` has
solution for it. Each time the server is starting (in development mode
for each request), the application will check the filesystem changes
of the map/reduce javascript files and update design document if
needed. Another good part is rails generator for views. It will puts
view stubs for you in proper places. Here for example model layout for
this particular application:

----
app/models/
├── beer
│   ├── all
│   │   └── map.js
│   └── by_category
│       ├── map.js
│       └── reduce.js
├── beer.rb
├── brewery
│   ├── all
│   │   └── map.js
│   ├── all_with_beers
│   │   └── map.js
│   ├── by_country
│   │   ├── map.js
│   │   └── reduce.js
│   └── points
│       └── spatial.js
├── brewery.rb
├── favorites.rb
└── user.rb
----

It is pretty straightforward, for each model which does have views,
you should create directory with the same name and put there special
javascript files. Those files should implement corresponding parts of
view. For example `_design/brewery/_view/by_country` does require both
map and reduce parts. To generate new view you should pass model name
and view name you need to get:

----
shell> rails generate couchbase:view beer test
      create  app/models/beer/test/map.js
      create  app/models/beer/test/reduce.js
----

Those automatically generated files are full of the comments, so they
are worth reading as quick start about how to write View indexes.

=== Implement Controllers

Now lets dissect controllers from the project. This is where data
selected to display to user. For example `BreweriesController`:

[code,ruby]
----
class BreweriesController < ApplicationController
  def index
    filter = params.extract!(:start_key, :end_key).reject{|_, v| v.blank?}
    @breweries = Brewery.all(filter).to_a
    if @breweries.size > 30
      @last_key = @breweries.pop.try(:key)
    end
    respond_to do |format|
      format.html
      format.json do
        render :json => {:last_key => @last_key, :items => @breweries}
      end
    end
  end

  def show
    @brewery, *@beers = Brewery.all_with_beers(:start_key => [params[:id]],
                                               :end_key => ["#{params[:id]}\uefff"]).to_a
  end
end
----

It has two actions:

. "index" which supposed to pull the list of breweries. It might looks
  complex, but it doesn't. In first line we are preparing query
  parameters for views. In particular we are interested in `start_key`
  and `end_key` parameters, but we need them only if they aren't blank
  (i.e. not nil and not empty string). The second step is to execute
  view and get results immediately. Your application might want to
  fetch the entries from view on demain in a lazy manner, then you no
  need to call `#to_a` method and just iterate them or call methods
  like `#next`. In this particular example we are fetchin 31 record
  and are trying to pop latest one to use it later for "infinite"
  scrolling. And the end of the method is responsible for rendering
  the data in two formats, by default it will use HTML, but if we are
  using AJAX request with `Accept: application/json` header, it will
  render the JSON representation of our models.

. "show" action uses another view from the `Brewery` model, which
  collates breweries with beer for easier access. Here is map function
  which does the job:
+
....
function(doc, meta) {
  switch(doc.type) {
  case "brewery":
    emit([meta.id]);
    break;
  case "beer":
    if (doc.brewery_id && doc.name) {
      emit([doc.brewery_id, doc.name]);
    }
    break;
  }
}
....
+
As you can see we are using compound key with brewery ID on the
first place an document name on the second, because we are selecting
only beer with not null names, they will be definitely sorted after
breweries. So that when we will filter result by the first key only,
`@brewery` variable will receive first element of the sequence, and
`@beers` will get the rest of the collection because of splat (`*`)
operator.

=== Bonus: Spatial Queries, Sessions and Cache

... To be done ...
